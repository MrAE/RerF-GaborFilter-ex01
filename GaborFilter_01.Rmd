---
title: "Blank RMarkdown file."
author: "Jesse Leigh Patsolic"
output: 
  html_document:
    keep_md: true
    code_folding: show
    self_contained: true
---

<!--
### ### INITIAL COMMENTS HERE ###
###
### Jesse Leigh Patsolic 
### 2018 <jpatsolic@jhu.edu>
### S.D.G 
#
-->

```{r render-code, eval=FALSE, echo=FALSE}
set.seed(3171)
require(rmarkdown)
require(knitr)
knitr::opts_chunk$set(cache=FALSE, autodep=TRUE, eval = TRUE)

rmarkdown::render("GaborFilter_01.Rmd")
system('open GaborFilter_01.html')
```

<style type="text/css">
.table {
    width: 40%;
}
tr:hover {background-color:#f5f5f5;}
</style>

```{r setup}
require(rmarkdown)
require(devtools)
require(raster)
require(ggplot2)
require(MCMCpack)
require(rerf)
require(data.table)
require(gridExtra)
require(rgl)
data(mnist)
```

# Introduction 

The Gabor filter as defined by Goodfellow et al. is given by 
$$ w(x,y; \alpha, \beta_x, \beta_y, f, \phi, x_0, y_0, \tau) = \alpha
\exp{(- \beta_x x'^2 - \beta_y y'^2 \color{red}{+ \beta_{xy}x'y'})} \cos{(fx' + \phi)} $$

the term in red is required if the correlation is non-zero, however
this term is missing from the definition in Goodfellow et al.

For reference the bivariate Gaussian is given by 

$$ f(x,y; \mu_x, \mu_y, \sigma_x, \sigma_y, \rho) = \frac{1}{2\pi\sigma_x\sigma_y(1 - \rho^2)}\exp{\left\{-\frac{1}{2(1 - \rho^2)}\left[\frac{(x - \mu_x)^2}{\sigma_x^2} \color{blue}{- \frac{2\rho(x - \mu_x)(y - \mu_y)}{\sigma_x\sigma_y(1 - \rho^2)}}+ \frac{(y - \mu_y)^2}{\sigma_y^2} \right]\right\}} $$

**The conjugate prior for a uni-variate normal with known mean is an inverse gamma.**



| |  0|  1|  2|  3|
|:--:|--:|--:|--:|--:|
|$\Sigma$    | NA           |  invW|  invW|  1|
|$\beta_x$   | $\Gamma(1,1)$|  $1/(2\sigma_x^2(1-\rho^2))$| ''|$1/(2\sigma_x^2)$|
|$\beta_y$   | $\Gamma(1,1)$|  $1/(2\sigma_y^2(1-\rho^2))$| ''|$1/(2\sigma_y^2)$|
|$\beta_{xy}$ | 0            |  $\rho/(\sigma_x\sigma_y(1-\rho^2))$|  0|  0|





```{r GaborFunctionDef}

#' The 2-d Gabor weight function
#'
#' 
#' @param x x coordinate 
#' @param y y coordinate 
#' @param alpha scaling factor of the Gaussian envelope
#' @param betax \eqn{\beta_x} decay factor in the x direction
#' @param betay \eqn{\beta_y} decay factor in the y direction
#' @param f frequency of the cosine factor
#' @param phi phase offset in the cosine factor
#' @param x0 mean in the x direction
#' @param y0 mean in the y direction
#' @param tau the angle of rotation for x and y
#'
#' @return a weight in the form of a scaler.
#'
#' @export
#' 
#' @references @unpublished{Goodfellow-et-al-2016-Book,
#'   title={Deep Learning},
#'   author={Ian Goodfellow, Yoshua Bengio, and Aaron Courville},
#'   note={Book in preparation for MIT Press},
#'   url={http://www.deeplearningbook.org},
#'   year={2016}
#' }
#'
#' @examples
#'
#' p <- 28^2
#' d <- 8
#' ih <- iw <- 28
#' pwMin <- 3
#' pwMax <- 6
#' paramList <- list(p = p, d = d, ih = ih, iw = iw, pwMin = pwMin, pwMax = pwMax)
#' set.seed(8)
#' (a <- do.call(RandMatImagePatch, paramList))

Gw <- function(x, y, alpha, betax, betay, f, phi, x0, y0, tau, betaxy = 0) {

  xp <-  (x - x0) * cos(tau) + (y - y0) * sin(tau)
  yp <- -(x - x0) * sin(tau) + (y - y0) * cos(tau)

  alpha * exp(- betax * xp^2 - betay * yp^2 + (betaxy * xp * yp)) * 
    cos(f * xp + phi)
}


#' Sample the hyper-parameters for the Gabor weight function
#'
#' 
#' @param n the number of samples
#' @param galpha the shape parameter for alpha
#' @param gbeta the shape parmeter for alpha
#' @param igalpha the shape parameter for betax and betay
#' @param igbeta the rate parameter for betax and betay
#'
#' @return a list of parameters for the Gabor Weight function.
#'
#' @export
#' 
#' @references @unpublished{Goodfellow-et-al-2016-Book,
#'   title={Deep Learning},
#'   author={Ian Goodfellow, Yoshua Bengio, and Aaron Courville},
#'   note={Book in preparation for MIT Press},
#'   url={http://www.deeplearningbook.org},
#'   year={2016}
#' }
#'
#' @examples
#'
#' params <- gabSamp()
#' ##  must specify grid
#' x <- seq(-4,4, length = 9)
#' xy <- expand.grid(x,x)
#' params$x <- xy[, 1]
#' params$y <- xy[, 2]
#' gw <- do.call(Gw, params)
#' 
#' 

gabSamp <- function(n = 1, galpha = 3, gbeta = 1, igalpha = 0.5, igbeta = 0.5, w = 0) { 
  out <- list()

  out$alpha <- 1 # rgamma(n, shape = galpha, rate = gbeta)
  out$betax <- rinvgamma(n, shape = igalpha, scale = igbeta)
  out$betay <- rinvgamma(n, shape = igalpha, scale = igbeta)
  out$f <- rgamma(n, shape = galpha, rate = gbeta)
  out$phi <- runif(n, min = 0, max = 2 * pi)
  out$x0 <- runif(n, min = -3.5, max = 3.5)#rnorm(n, mean = 0, sd = 0.75)
  out$y0 <- runif(n, min = -3.5, max = 3.5)#rnorm(n, mean = 0, sd = 0.75)
  out$tau <- runif(n, min = 0, max = 2 * pi)

  if(w == 1){
    # Letter B
    S <- riwish(v = 2, S = diag(2))
    sigx2 <- S[1]
    sigy2 <- S[4]
    rho <- S[2] / (sqrt(sigx2) * sqrt(sigy2))
    out$betax <- 1 / (2 * sigx2  * (1 - rho^2))
    out$betay <- 1 / (2 * sigy2  * (1 - rho^2))
    out$betaxy <- rho / (sqrt(sigx2) * sqrt(sigy2) * (1 - rho^2))
  }

  if(w == 2){
    # Letter C
    S <- riwish(v = 2, S = diag(2))
    sigx2 <- S[1]
    sigy2 <- S[4]
    rho <- S[2] / (sqrt(sigx2) * sqrt(sigy2))
    out$betax <- 1 / (2 * sigx2  * (1 - rho^2))
    out$betay <- 1 / (2 * sigy2  * (1 - rho^2))
    out$betaxy <- 0
  }

  if(w == 3){
    # letter D
    S <- riwish(v = 2, S = diag(2))
    sigx2 <- S[1]
    sigy2 <- S[4]
    out$betax <- 1 / (2 * sigx2)
    out$betay <- 1 / (2 * sigy2)
    out$betaxy <- 0
  }

  return(out)
}
```


```{r param-test, eval = TRUE, include = FALSE}
n <- 64
w <- 28
h <- 28
sw <- seq(-3.5, 3.5, length = w)
sh <- seq(3.5, -3.5, length = h)
xy <- expand.grid(sw,sh)

x <- xy[, 1]
y <- xy[, 2]

#params <- list()

alpha <- 10
betax <- sample(seq(0.01, 1,by = 0.1), 1)#rinvgamma(1, 1,0.75)
betay <- sample(seq(0.01, 1,by=0.1), 1)#rinvgamma(1, 1, 0.75) 
f <- rgamma(1, shape = 3, rate = 1)
phi <- pi / 3
x0 <- runif(1, -3,3)
y0 <- runif(1, -3,3) 
tau <- pi

#G1 <- do.call(w, params)

G1 <- Gw(x, y, alpha, betax, betay, f, phi, x0, y0, tau)
d1 <- cbind(xy,G1)

#ggplot(data = d1, aes(x = Var1, y = Var2, fill = G1)) + geom_raster() + scale_fill_distiller(palette = "Spectral")
pq <- ggplot(data = d1, aes(x = Var1, y = Var2, fill = G1)) + 
  geom_raster() + 
  scale_fill_gradient2(low = "blue", mid = 'white', high = 'red')
plot(pq)
```


# Sampling Gabor filters


Given a random patch with height `h` and width `w` how do we sample a corresponding Gabor filter?

```{r check-looks-like-gabor}
set.seed(12345)
# plots list
p1 <- list()
pm <- list()
im <- matrix(mnist$Xtrain[1,], 28, 28)
## Get a random subsample, 100 each of 3's and 5's
set.seed(320)
threes <- sample(which(mnist$Ytrain %in% 3), 100)
fives  <- sample(which(mnist$Ytrain %in% 5), 100)
numsub <- c(threes, fives)

Ytrain <- mnist$Ytrain[numsub]
Xtrain <- mnist$Xtrain[numsub,]
Ytest <- mnist$Ytest[mnist$Ytest %in% c(3,5)]
Xtest <- mnist$Xtest[mnist$Ytest %in% c(3,5),]
X <- Xtrain[1, ]
#
#for(i in sample(200)){
#  X <- Xtrain[i,]
#  plot(as.raster(matrix(X, 28, 28)))
#  Sys.sleep(0.5)
#  plot(raster::raster(matrix(X * G1, 28, 28)), col = gray.colors(255))
#  Sys.sleep(0.5)
#}

w <- 28

for(i in 1:36) {
  s  <- seq(-4, 4, length = w)

  xy <- expand.grid(s,s)
  
  param <- gabSamp(w = 3)

  param$x <- xy[, 1]
  param$y <- xy[, 2]

  G1 <- do.call(Gw, param)

  d1 <- data.table(cbind(xy,G1, GX = G1 * X))

  
  #ggplot(data = d1, aes(x = Var1, y = Var2, fill = G1)) + geom_raster() + scale_fill_distiller(palette = "Spectral")
  p1[[i]] <- ggplot(data = d1, aes(x = Var1, y = Var2, fill = G1)) + geom_raster() + scale_fill_gradient2(low = "blue", mid = 'white', high = 'red') + guides(fill = FALSE)

  pm[[i]] <- ggplot(data = d1, aes(x = Var1, y = Var2, fill = GX)) + geom_raster() + scale_fill_gradient2(low = "blue", mid = 'white', high = 'red') + guides(fill = FALSE)
}
```


```{r, fig.height = 8, fig.width = 8}
do.call(grid.arrange, p1)  
```


### R-RerF RandMatImageGabor

```{r RandMatGabor-Def}

#' Create a Random Matrix: For an Image with Gabor weighting
#' 
#' The pathces are specified to be square, because the Gabor filter
#' takes care of the "squishing".
#' Also the minimum patch size should be 3x3.
#'
#' @param p the number of dimensions.
#' @param d the number of desired columns in the projection matrix.
#' @param ih the height (px) of the image.
#' @param iw the width (px) of the image.
#' @param pwMin the minimum patch size to sample.
#' @param pwMax the maximum patch size to sample.
#' @param ... used to handle superfluous arguments passed in using paramList.
#'
#' @return A random matrix to use in running \code{\link{RerF}}.
#'
#' @export
#'
#' @examples
#'
#' ih <- iw <- 28
#' p <- 28^2
#' d <- 28
#' paramList <- list(p = p, d = d, ih = ih, iw = iw)
#' set.seed(8)
#' (a <- do.call(RandMatImageGabor, paramList))
#' for(i in 1:d){
#'   plot(raster::raster(matrix(a[a[, 2] == i,][, 3L] , 28, 28)))
#'   Sys.sleep(0.6)
#' }
#' 

RandMatImageGabor <- function(p, d, ih, iw, tol = .Machine$double.eps, whG = 0, ...) {

  ## Sample Gabor Filter
  gx <-  seq(-2.5, 2.5, length = iw) 
  gy <-  seq(2.5, -2.5, length = ih)
  gridXY <- expand.grid(gx, gy)
  gaborBank <- list()
  for(i in 1:d){
    params <- gabSamp(w = whG) ## 3 = letter c
    params$x <- gridXY[, 1]
    params$y <- gridXY[, 2]
    gaborBank[[i]] <- do.call(Gw, params)
    #if(DEBUG){
    #  plot(raster::raster(matrix(gaborBank[[i]], 28, 28)))
    #  Sys.sleep(1)
    #}
  }

#plot(raster::raster(matrix(X, 28, 28))) 
#plot(raster::raster(matrix(G1, 28, 28))) 
#plot(raster::raster(matrix(X * G1, 28, 28))) 

  nz.rows <- rep(1:p, d)
  nz.cols <- rep(1:d, each = p)

  w <- Reduce('c', gaborBank)
  w[w <= tol & w >= -tol] <- 0 ## NOTE: This is not efficient

  ## remove w within delta ball of zero to save space
  random.matrix <- 
    as.matrix(cbind(nz.rows = nz.rows, nz.cols = nz.cols, w = w))[w != 0, ]
}
```

```{r mnist-sub}
## Get a random subsample, 100 each of 3's and 5's
set.seed(320)
zeros  <- sample(which(mnist$Ytrain %in% 0), 100)
ones   <- sample(which(mnist$Ytrain %in% 1), 100)
twos   <- sample(which(mnist$Ytrain %in% 2), 100)
threes <- sample(which(mnist$Ytrain %in% 3), 100)
eights <- sample(which(mnist$Ytrain %in% 8), 100)

numsub <- c(zeros, ones, eights)

Ytrain <- mnist$Ytrain[numsub]
Xtrain <- mnist$Xtrain[numsub,]

Ytest <- mnist$Ytest[mnist$Ytest %in% c(0, 1, 8)]
Xtest <- mnist$Xtest[mnist$Ytest %in% c(0, 1, 8),]

#s1 <- sample(nrow(Xtest))
#Ytrain <- mnist$Ytrain
#Xtrain <- mnist$Xtrain
#
#Ytest <- mnist$Ytest
#Xtest <- mnist$Xtest
```

## Run RerF with different parameter settings on a subset of MNIST
```{r randmatTest-setup}
# p is number of dimensions, d is the number of random features to evaluate, iw is image width, ih is image height, patch.min is min width of square patch to sample pixels from, and patch.max is the max width of square patch
p <- ncol(Xtrain)
d <- ceiling(sqrt(p))
iw <- sqrt(p)
ih <- iw
patch.min <- 2L
patch.max <- 10L

ntrees <- 500L
ncores <- 7L
seed1 <- 1L

```

### Parameters

```{r, results = 'asis'}
kable(as.data.frame((params <- list(p = p, d = d, iw = iw, ih = ih, pwMin = patch.min, pwMax = patch.max, sparsity = 1, whG = 1))))
```


### Image-Patch 

```{r RerF-image-patch}
system.time({
forestIP <- RerF(Xtrain, Ytrain,  FUN = RandMatImagePatch, 
               paramList = params,
               trees = ntrees, 
               num.cores = ncores, seed = seed1)
})

predIP <- Predict(Xtest, forestIP, num.cores = ncores)
(errorIP <- mean(predIP != Ytest))
```


### RerF Continuous

NOTE: that sparsity has been set to 1.

```{r RerF-Continuous}
#params <- list(p = p, d = d, sparsity = 1)
system.time({
forestC <- RerF(Xtrain, Ytrain,  FUN = RandMatContinuous, 
               paramList = params,
               trees = ntrees,
               num.cores = ncores, seed = seed1)
})

predC <- Predict(Xtest, forestC, num.cores = ncores)
(errorC <- mean(predC != Ytest))
```

### RerF Gabor

```{r RerF-Gabor}
#params <- list(p = p, d = d, iw = 28, ih = 28)
params$whG <- 0
system.time({
forestG0 <- RerF(Xtrain, Ytrain,  FUN = RandMatImageGabor,
               paramList = params,
               trees = ntrees,
               num.cores = ncores, seed = seed1)
})

predG0 <- Predict(Xtest, forestG0, num.cores = ncores)
(errorG0 <- mean(predG0 != Ytest))

params$whG <- 1
system.time({
forestG1 <- RerF(Xtrain, Ytrain,  FUN = RandMatImageGabor,
               paramList = params,
               trees = ntrees,
               num.cores = ncores, seed = seed1)
})

predG1 <- Predict(Xtest, forestG1, num.cores = ncores)
(errorG1 <- mean(predG1 != Ytest))

params$whG <- 2
system.time({
forestG2 <- RerF(Xtrain, Ytrain,  FUN = RandMatImageGabor,
               paramList = params,
               trees = ntrees,
               num.cores = ncores, seed = seed1)
})

predG2 <- Predict(Xtest, forestG2, num.cores = ncores)
(errorG2 <- mean(predG2 != Ytest))

params$whG <- 3
system.time({
forestG3 <- RerF(Xtrain, Ytrain,  FUN = RandMatImageGabor,
               paramList = params,
               trees = ntrees,
               num.cores = ncores, seed = seed1)
})

predG3 <- Predict(Xtest, forestG3, num.cores = ncores)
(errorG3 <- mean(predG3 != Ytest))
```

## results
```{r, echo = FALSE, results = 'asis'}
oe <- data.frame(
  cbind(
        Gabor0 = errorG0, 
        Gabor1 = errorG1, 
        Gabor2 = errorG2, 
        Gabor3 = errorG3, 
        ImagePatch = errorIP, Continuous = errorC))
kable(oe[, order(oe[1, ])])
```







<!--
#   Time:
##  Working status:
### Comments:
####Soli Deo Gloria
--> 

